const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const Certificate = require('../models/Certificate');
const Activity = require('../models/Activity');
const User = require('../models/User');
const authMiddleware = require('../middleware/auth');
const { sendCertificateEmail, sendConsolidatedCertificatesEmail } = require('../utils/emailService');

// ========== GENERATE CERTIFICATE ==========
router.post('/generate/:activityId', authMiddleware, async (req, res) => {
  try {
    console.log('\n' + '='.repeat(70));
    console.log('üìú GENERATING CERTIFICATE');
    console.log('='.repeat(70));
    console.log('Activity ID:', req.params.activityId);

    const activity = await Activity.findById(req.params.activityId)
      .populate('student', 'name email');

    if (!activity) {
      return res.status(404).json({ error: 'Activity not found' });
    }

    const certificateId = `CERT_${activity._id.toString().slice(0, 8)}_${Date.now()}`;
    const certificatePath = path.join(__dirname, `../uploads/certificates/${certificateId}.pdf`);

    const dir = path.dirname(certificatePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    const certificateContent = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                  CERTIFICATE OF ACHIEVEMENT                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

     This is to certify that

          ${activity.student.name}

     has successfully completed

          ${activity.title}

     Category: ${activity.category}
     Level: ${activity.achievementLevel}
     Organizing Body: ${activity.organizingBody || 'N/A'}
     Event Date: ${activity.eventDate ? new Date(activity.eventDate).toLocaleDateString() : 'N/A'}

     Issued on: ${new Date().toLocaleDateString()}

     This certificate is cryptographically secured.
     Certificate ID: ${certificateId}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Generated by: AchievR - Credential Verification System
    `;

    fs.writeFileSync(certificatePath, certificateContent);
    console.log('‚úÖ Certificate file created');
    console.log('='.repeat(70) + '\n');

    res.json({
      success: true,
      certificateId,
      certificatePath,
      studentName: activity.student.name,
      studentEmail: activity.student.email,
      studentId: activity.student._id,
      achievement: activity.title,
      description: activity.description,
      organizingBody: activity.organizingBody,
      achievementLevel: activity.achievementLevel,
      eventDate: activity.eventDate?.toLocaleDateString(),
      message: '‚úÖ Certificate generated. Click "Send to Student" to email.'
    });

  } catch (error) {
    console.error('‚ùå Error:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// ========== SUBMIT & SEND CERTIFICATE ==========
router.post('/submit/:activityId', authMiddleware, async (req, res) => {
  try {
    console.log('\n' + '='.repeat(70));
    console.log('üìß CERTIFICATE SUBMIT & EMAIL PROCESS');
    console.log('='.repeat(70));

    const {
      certificateId,
      certificatePath,
      studentName,
      studentEmail,
      studentId,
      achievement,
      organizingBody,
      achievementLevel,
      eventDate
    } = req.body;

    // ========== VALIDATION ==========
    console.log('\n‚úÖ Step 1: VALIDATION');
    console.log(`   Certificate ID: ${certificateId}`);
    console.log(`   Student Email: ${studentEmail}`);
    console.log(`   Student Name: ${studentName}`);

    if (!certificateId || !certificatePath || !studentEmail || !studentName) {
      console.log('‚ùå Missing required fields');
      return res.status(400).json({ error: 'Missing required fields' });
    }
    console.log('‚úÖ All fields validated');

    // ========== FILE CHECK ==========
    console.log('\n‚úÖ Step 2: FILE CHECK');
    console.log(`   File path: ${certificatePath}`);
    
    if (!fs.existsSync(certificatePath)) {
      console.log(`‚ùå File not found!`);
      return res.status(404).json({ error: `File not found: ${certificatePath}` });
    }
    
    const fileSize = fs.statSync(certificatePath).size;
    console.log(`‚úÖ File found (${(fileSize / 1024).toFixed(2)} KB)`);

    // ========== SAVE TO DATABASE ==========
    console.log('\n‚úÖ Step 3: DATABASE SAVE');
    
    const verificationCode = crypto.randomBytes(16).toString('hex');
    console.log(`   Verification Code: ${verificationCode.substring(0, 16)}...`);

    let certificate = await Certificate.findOne({ certificateId });
    
    if (certificate) {
      console.log('‚ö†Ô∏è Certificate already exists, updating...');
      certificate.verificationCode = verificationCode;
      certificate.emailStatus = 'pending';
    } else {
      certificate = new Certificate({
        certificateId,
        activity: req.params.activityId,
        student: studentId,
        issuedBy: req.user.userId,
        title: achievement,
        description: req.body.description || '',
        organizingBody: organizingBody,
        achievementLevel: achievementLevel,
        eventDate: eventDate,
        pdfPath: certificatePath,
        verificationCode,
        status: 'active',
        issuedAt: new Date()
      });
    }

    await certificate.save();
    console.log(`‚úÖ Certificate saved to DB`);

    // ========== SEND EMAIL ==========
    console.log('\n‚úÖ Step 4: SENDING EMAIL');
    console.log(`   To: ${studentEmail}`);

    try {
      const emailResult = await sendCertificateEmail(
        studentEmail,
        studentName,
        {
          certificateId,
          certificatePath,
          achievement,
          organizingBody,
          eventDate,
          achievementLevel,
          verificationCode
        }
      );

      if (emailResult && emailResult.success) {
        await certificate.recordEmailSent(studentEmail, emailResult.messageId, 'sent');
        console.log('‚úÖ Email sent successfully');
      } else {
        await certificate.recordEmailSent(studentEmail, 'N/A', 'failed', 'Email service error');
        console.log('‚ö†Ô∏è Email failed');
      }
    } catch (emailError) {
      console.error('‚ö†Ô∏è Email error:', emailError.message);
      await certificate.recordEmailSent(studentEmail, 'N/A', 'failed', emailError.message);
    }

    // ========== UPDATE ACTIVITY ==========
    console.log('\n‚úÖ Step 5: UPDATE ACTIVITY');
    
    await Activity.findByIdAndUpdate(
      req.params.activityId,
      {
        certificate: certificate._id,
        certificateId: certificateId,
        certificatePath: certificatePath,
        status: 'certified',
        certificateGeneratedAt: new Date(),
        certificateGeneratedBy: req.user.userId
      }
    );

    console.log('‚úÖ Activity updated');
    console.log('='.repeat(70));
    console.log('üéâ SUCCESS!\n');

    res.json({
      success: true,
      message: '‚úÖ Certificate sent successfully!',
      certificateId,
      studentEmail,
      verificationCode,
      emailStats: certificate.getEmailStats()
    });

  } catch (error) {
    console.error('‚ùå ERROR:', error.message);
    console.log('='.repeat(70) + '\n');
    
    res.status(500).json({ error: error.message });
  }
});

// ========== SEND/RESEND EMAIL (NO COOLDOWN) ==========
router.post('/send/:certificateId', authMiddleware, async (req, res) => {
  try {
    console.log(`\nüìß Sending certificate email...`);

    const certificate = await Certificate.findById(req.params.certificateId)
      .populate('student', 'name email')
      .populate('activity', 'title');

    if (!certificate) {
      return res.status(404).json({ error: 'Certificate not found' });
    }

    console.log(`   To: ${certificate.student.email}`);

    const emailResult = await sendCertificateEmail(
      certificate.student.email,
      certificate.student.name,
      {
        certificateId: certificate.certificateId,
        certificatePath: certificate.pdfPath,
        achievement: certificate.title,
        organizingBody: certificate.organizingBody,
        eventDate: certificate.eventDate,
        achievementLevel: certificate.achievementLevel,
        verificationCode: certificate.verificationCode
      }
    );

    if (!emailResult || !emailResult.success) {
      await certificate.recordEmailSent(certificate.student.email, 'N/A', 'failed', 'Email service error');
      return res.status(500).json({
        success: false,
        error: 'Failed to send email'
      });
    }

    await certificate.recordEmailSent(certificate.student.email, emailResult.messageId || 'N/A', 'sent');
    console.log('‚úÖ Email sent\n');

    res.json({
      success: true,
      message: '‚úÖ Email sent successfully!',
      studentEmail: certificate.student.email,
      emailStats: certificate.getEmailStats()
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== GET STUDENT CERTIFICATES ==========
router.get('/student/:studentId', async (req, res) => {
  try {
    console.log(`üìã Fetching certificates for student: ${req.params.studentId}`);

    const certificates = await Certificate.findByStudent(req.params.studentId)
      .populate('activity', 'title category eventDate')
      .populate('issuedBy', 'name');

    console.log(`‚úÖ Found ${certificates.length} certificates`);

    res.json({
      success: true,
      total: certificates.length,
      certificates: certificates.map(c => ({
        _id: c._id,
        certificateId: c.certificateId,
        title: c.title,
        activity: c.activity,
        issuedAt: c.issuedAt,
        status: c.status,
        emailStats: c.getEmailStats(),
        verificationStats: c.getVerificationStats(),
        allStats: c.getAllStats()
      }))
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== GET ACTIVITY CERTIFICATES ==========
router.get('/activity/:activityId', async (req, res) => {
  try {
    console.log(`üìã Fetching certificates for activity: ${req.params.activityId}`);

    const certificates = await Certificate.findByActivity(req.params.activityId)
      .populate('student', 'name email rollNumber')
      .populate('issuedBy', 'name');

    console.log(`‚úÖ Found ${certificates.length} certificates`);

    res.json({
      success: true,
      total: certificates.length,
      certificates
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== GET ALL STUDENT CERTIFICATES ==========
router.get('/all/:studentId', async (req, res) => {
  try {
    console.log(`üìã Fetching all certificates for student: ${req.params.studentId}`);

    const student = await User.findById(req.params.studentId);
    if (!student) {
      return res.status(404).json({ error: 'Student not found' });
    }

    const certificates = await Certificate.find({ student: req.params.studentId })
      .populate('activity', 'title category eventDate')
      .populate('issuedBy', 'name')
      .sort({ issuedAt: -1 });

    console.log(`‚úÖ Found ${certificates.length} certificates`);

    const stats = {
      total: certificates.length,
      active: certificates.filter(c => c.status === 'active' && !c.isRevoked).length,
      revoked: certificates.filter(c => c.isRevoked).length,
      expired: certificates.filter(c => c.isExpired).length,
      pending: certificates.filter(c => c.emailStatus === 'pending').length,
      sent: certificates.filter(c => c.emailStatus === 'sent').length,
      failed: certificates.filter(c => c.emailStatus === 'failed').length
    };

    res.json({
      success: true,
      studentName: student.name,
      studentEmail: student.email,
      stats,
      certificates: certificates.map(c => ({
        _id: c._id,
        certificateId: c.certificateId,
        title: c.title,
        activity: c.activity,
        status: c.status,
        emailStatus: c.emailStatus,
        isValid: c.isValid,
        issuedAt: c.issuedAt,
        expiresAt: c.expiresAt,
        emailStats: c.getEmailStats(),
        verificationStats: c.getVerificationStats()
      }))
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== DOWNLOAD CERTIFICATE ==========
router.get('/download/:certificateId', async (req, res) => {
  try {
    console.log(`üì• Downloading certificate: ${req.params.certificateId}`);

    const certificate = await Certificate.findById(req.params.certificateId);

    if (!certificate) {
      return res.status(404).json({ error: 'Certificate not found' });
    }

    console.log('üìÇ PDF Path:', certificate.pdfPath);
    console.log('‚úÖ File exists:', fs.existsSync(certificate.pdfPath));

    if (!fs.existsSync(certificate.pdfPath)) {
      console.error('‚ùå File not found at:', certificate.pdfPath);
      return res.status(404).json({ error: `File not found: ${certificate.pdfPath}` });
    }

    await Certificate.updateOne(
      { _id: req.params.certificateId },
      { 
        $inc: { downloadCount: 1 },
        lastDownloadedAt: new Date()
      }
    );

    console.log('‚úÖ Download counted');
    
    const filePath = path.resolve(certificate.pdfPath);
    res.download(filePath, `${certificate.certificateId}.pdf`, (err) => {
      if (err) {
        console.error('‚ùå Download error:', err);
      } else {
        console.log('‚úÖ Download successful');
      }
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== VIEW CERTIFICATE ==========
router.get('/view/:certificateId', async (req, res) => {
  try {
    console.log(`üëÅÔ∏è Viewing certificate: ${req.params.certificateId}`);

    const certificate = await Certificate.findById(req.params.certificateId);

    if (!certificate) {
      return res.status(404).json({ error: 'Certificate not found' });
    }

    console.log('üìÇ PDF Path:', certificate.pdfPath);
    console.log('‚úÖ File exists:', fs.existsSync(certificate.pdfPath));

    if (!fs.existsSync(certificate.pdfPath)) {
      console.error('‚ùå File not found at:', certificate.pdfPath);
      return res.status(404).json({ error: `File not found: ${certificate.pdfPath}` });
    }

    await Certificate.updateOne(
      { _id: req.params.certificateId },
      { 
        $inc: { viewCount: 1 },
        lastViewedAt: new Date()
      }
    );

    console.log('‚úÖ View counted');
    
    const filePath = path.resolve(certificate.pdfPath);
    res.contentType('application/pdf');
    res.sendFile(filePath, (err) => {
      if (err) {
        console.error('‚ùå View error:', err);
      } else {
        console.log('‚úÖ View successful');
      }
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== VERIFY CERTIFICATE (PUBLIC) ==========
router.get('/verify/:certificateId', async (req, res) => {
  try {
    console.log(`üîç Verifying certificate: ${req.params.certificateId}`);

    const certificate = await Certificate.findById(req.params.certificateId)
      .populate('student', 'name email rollNumber')
      .populate('activity', 'title category')
      .populate('issuedBy', 'name email');

    if (!certificate) {
      console.log('‚ùå Certificate not found');
      return res.status(404).json({
        verified: false,
        message: 'Certificate not found'
      });
    }

    if (!certificate.isValid) {
      console.log('‚ùå Certificate invalid or revoked');
      return res.status(403).json({
        verified: false,
        message: 'Certificate is invalid or revoked'
      });
    }

    const clientIp = req.ip || req.connection.remoteAddress;
    await certificate.recordVerification(req.query.email || 'public', clientIp);

    console.log('‚úÖ Certificate verified');

    res.json({
      verified: true,
      data: {
        certificateId: certificate.certificateId,
        studentName: certificate.student.name,
        studentEmail: certificate.student.email,
        studentRollNumber: certificate.student.rollNumber,
        achievement: certificate.activity.title,
        achievementCategory: certificate.activity.category,
        organizingBody: certificate.organizingBody,
        achievementLevel: certificate.achievementLevel,
        issuedDate: certificate.issuedAt,
        expiresDate: certificate.expiresAt,
        status: certificate.status,
        verificationCount: certificate.verificationCount,
        issuedBy: certificate.issuedBy.name,
        isValid: certificate.isValid
      }
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== GET STATISTICS ==========
router.get('/stats/all', authMiddleware, async (req, res) => {
  try {
    console.log('üìä Fetching statistics...');

    const stats = await Certificate.getStatistics();
    
    console.log('‚úÖ Statistics fetched');

    res.json({
      success: true,
      statistics: stats[0] || {}
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== REVOKE CERTIFICATE ==========
router.put('/revoke/:certificateId', authMiddleware, async (req, res) => {
  try {
    const { reason } = req.body;

    console.log(`üö´ Revoking certificate: ${req.params.certificateId}`);
    console.log(`   Reason: ${reason}`);

    const certificate = await Certificate.findByIdAndUpdate(
      req.params.certificateId,
      {
        $set: {
          isRevoked: true,
          status: 'revoked',
          revocationReason: reason || 'No reason provided',
          revokedAt: new Date(),
          updatedAt: new Date()
        }
      },
      { new: true }
    ).populate('student', 'name email');

    if (!certificate) {
      return res.status(404).json({ error: 'Certificate not found' });
    }

    console.log('‚úÖ Certificate revoked');

    res.json({
      success: true,
      message: '‚úÖ Certificate revoked',
      certificate: {
        certificateId: certificate.certificateId,
        status: certificate.status,
        revokedAt: certificate.revokedAt
      }
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== SEND ALL CERTIFICATES TO STUDENT ==========
router.post('/send-all/:studentId', authMiddleware, async (req, res) => {
  try {
    console.log('\n' + '='.repeat(70));
    console.log('üìß SENDING ALL CERTIFICATES TO STUDENT');
    console.log('='.repeat(70));

    const user = await User.findById(req.user.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: 'Only admin can perform this action' });
    }

    const student = await User.findById(req.params.studentId);
    if (!student) {
      return res.status(404).json({ error: 'Student not found' });
    }

    console.log(`üë§ Student: ${student.name} (${student.email})`);

    const certificates = await Certificate.find({ 
      student: req.params.studentId,
      status: 'active',
      isRevoked: false
    })
      .populate('activity', 'title category')
      .sort({ issuedAt: -1 });

    if (certificates.length === 0) {
      return res.status(404).json({ 
        success: false,
        error: 'No active certificates found for this student'
      });
    }

    console.log(`üìú Total certificates: ${certificates.length}`);

    let certificatesList = '';
    certificates.forEach((cert, idx) => {
      certificatesList += `
        <div class="cert-item">
          <h4>#${idx + 1} - ${cert.activity?.title || cert.title}</h4>
          <p>Category: <strong>${cert.activity?.category || 'N/A'}</strong></p>
          <p>Organization: <strong>${cert.organizingBody || 'N/A'}</strong></p>
          <p>Level: <strong>${cert.achievementLevel}</strong></p>
          <p>Issued: <strong>${new Date(cert.issuedAt).toLocaleDateString()}</strong></p>
          <div class="cert-id">ID: ${cert.certificateId}</div>
        </div>
      `;
    });

    console.log('üì® Sending consolidated email with all certificates...');
    
    const emailResult = await sendConsolidatedCertificatesEmail(
      student.email,
      student.name,
      certificates,
      certificatesList
    );

    if (!emailResult || !emailResult.success) {
      console.error('‚ùå Email failed:', emailResult?.error);
      
      await Promise.all(
        certificates.map(cert => 
          cert.recordEmailSent(student.email, 'N/A', 'failed', emailResult?.error)
        )
      );

      return res.status(500).json({
        success: false,
        error: 'Failed to send email',
        totalCertificates: certificates.length,
        sent: 0,
        failed: certificates.length
      });
    }

    console.log('‚úÖ Email sent successfully');

    await Promise.all(
      certificates.map(cert => 
        cert.recordEmailSent(student.email, emailResult.messageId, 'sent')
      )
    );

    console.log(`‚úÖ Updated ${certificates.length} certificates`);
    console.log('='.repeat(70) + '\n');

    res.json({
      success: true,
      message: `‚úÖ All ${certificates.length} certificate(s) sent to ${student.email}`,
      studentId: req.params.studentId,
      studentName: student.name,
      studentEmail: student.email,
      totalCertificates: certificates.length,
      certificates: certificates.map(c => ({
        certificateId: c.certificateId,
        title: c.title,
        activity: c.activity?.title,
        issuedAt: c.issuedAt,
        status: c.emailStatus
      })),
      emailStats: {
        sent: certificates.length,
        failed: 0,
        messageId: emailResult.messageId
      }
    });

  } catch (error) {
    console.error('‚ùå Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== RESEND FAILED EMAILS ==========
router.post('/resend-failed/:studentId', authMiddleware, async (req, res) => {
  try {
    console.log(`\nüìß RESENDING FAILED CERTIFICATES`);

    const user = await User.findById(req.user.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    const student = await User.findById(req.params.studentId);
    if (!student) {
      return res.status(404).json({ error: 'Student not found' });
    }

    console.log(`üìß Resending to: ${student.email}`);

    const failedCerts = await Certificate.find({
      student: req.params.studentId,
      emailStatus: 'failed'
    }).sort({ issuedAt: -1 });

    if (failedCerts.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No failed certificates to resend'
      });
    }

    console.log(`Found ${failedCerts.length} failed certificates`);

    let successCount = 0;
    let failCount = 0;

    for (const cert of failedCerts) {
      try {
        const emailResult = await sendCertificateEmail(
          student.email,
          student.name,
          {
            certificateId: cert.certificateId,
            certificatePath: cert.pdfPath,
            achievement: cert.title,
            organizingBody: cert.organizingBody,
            eventDate: cert.eventDate,
            achievementLevel: cert.achievementLevel,
            verificationCode: cert.verificationCode
          }
        );

        if (emailResult && emailResult.success) {
          await cert.recordEmailSent(student.email, emailResult.messageId, 'sent');
          successCount++;
          console.log(`‚úÖ Resent: ${cert.certificateId}`);
        }
      } catch (err) {
        failCount++;
        console.error(`‚ùå Failed: ${cert.certificateId}`);
      }
    }

    console.log(`\nResults: ${successCount} resent, ${failCount} failed\n`);

    res.json({
      success: true,
      message: `‚úÖ Resend complete`,
      total: failedCerts.length,
      successCount,
      failCount,
      studentEmail: student.email
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== RESEND ALL CERTIFICATES ==========
router.post('/resend-all/:studentId', authMiddleware, async (req, res) => {
  try {
    console.log(`\nüìß RESENDING ALL CERTIFICATES TO STUDENT`);

    const user = await User.findById(req.user.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: 'Only admin can perform this action' });
    }

    const student = await User.findById(req.params.studentId);
    if (!student) {
      return res.status(404).json({ error: 'Student not found' });
    }

    console.log(`üë§ Student: ${student.name} (${student.email})`);

    const certificates = await Certificate.find({ 
      student: req.params.studentId,
      status: 'active'
    }).sort({ issuedAt: -1 });

    if (certificates.length === 0) {
      return res.status(404).json({ 
        success: false,
        error: 'No certificates found'
      });
    }

    console.log(`üìú Resending ${certificates.length} certificates...`);

    let successCount = 0;
    let failCount = 0;

    for (const cert of certificates) {
      try {
        const emailResult = await sendCertificateEmail(
          student.email,
          student.name,
          {
            certificateId: cert.certificateId,
            certificatePath: cert.pdfPath,
            achievement: cert.title,
            organizingBody: cert.organizingBody,
            eventDate: cert.eventDate,
            achievementLevel: cert.achievementLevel,
            verificationCode: cert.verificationCode
          }
        );

        if (emailResult && emailResult.success) {
          await cert.recordEmailSent(student.email, emailResult.messageId, 'sent');
          successCount++;
          console.log(`‚úÖ Sent: ${cert.certificateId}`);
        } else {
          failCount++;
          await cert.recordEmailSent(student.email, 'N/A', 'failed', 'Service error');
          console.log(`‚ùå Failed: ${cert.certificateId}`);
        }
      } catch (err) {
        failCount++;
        console.error(`‚ùå Error sending ${cert.certificateId}:`, err.message);
      }
    }

    console.log(`\n‚úÖ Sent: ${successCount}, ‚ùå Failed: ${failCount}\n`);

    res.json({
      success: true,
      message: `Resent ${successCount} certificates`,
      total: certificates.length,
      successCount,
      failCount,
      studentEmail: student.email
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ========== BULK SEND CERTIFICATES (Individual Emails) ==========
router.post('/bulk-send/:studentId', authMiddleware, async (req, res) => {
  try {
    console.log(`üìß Bulk sending certificates to student: ${req.params.studentId}`);

    const certificates = await Certificate.findByStudent(req.params.studentId)
      .populate('student', 'name email');

    if (certificates.length === 0) {
      return res.status(404).json({ error: 'No certificates found for student' });
    }

    const student = certificates[0].student;
    console.log(`   Total certificates: ${certificates.length}`);
    console.log(`   Student: ${student.name} (${student.email})`);

    let successCount = 0;
    let failCount = 0;

    for (const cert of certificates) {
      try {
        const emailResult = await sendCertificateEmail(
          student.email,
          student.name,
          {
            certificateId: cert.certificateId,
            certificatePath: cert.pdfPath,
            achievement: cert.title,
            organizingBody: cert.organizingBody,
            eventDate: cert.eventDate,
            achievementLevel: cert.achievementLevel,
            verificationCode: cert.verificationCode
          }
        );

        if (emailResult && emailResult.success) {
          await cert.recordEmailSent(student.email, emailResult.messageId || 'N/A', 'sent');
          successCount++;
          console.log(`   ‚úÖ Sent: ${cert.certificateId}`);
        }
      } catch (err) {
        failCount++;
        await cert.recordEmailSent(student.email, 'N/A', 'failed', err.message);
        console.error(`   ‚ùå Failed: ${cert.certificateId}`);
      }
    }

    console.log(`\nResults: ${successCount} sent, ${failCount} failed\n`);

    res.json({
      success: true,
      message: `‚úÖ Bulk send complete`,
      total: certificates.length,
      successCount,
      failCount,
      studentEmail: student.email
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
