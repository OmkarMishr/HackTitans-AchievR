const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const Certificate = require('../models/Certificate');
const Activity = require('../models/Activity');
const User = require('../models/User');
const authMiddleware = require('../middleware/auth');
const emailService = require('../utils/emailService');

// ========== GENERATE CERTIFICATE ==========
router.post('/generate/:activityId', authMiddleware, async (req, res) => {
  try {
    console.log('\n' + '='.repeat(70));
    console.log('ðŸ“œ GENERATING CERTIFICATE');
    console.log('='.repeat(70));

    const activity = await Activity.findById(req.params.activityId)
      .populate('student', 'name email');

    if (!activity) {
      return res.status(404).json({ error: 'Activity not found' });
    }

    const certificateId = `CERT_${activity._id.toString().slice(0, 8)}_${Date.now()}`;
    const certificatePath = path.join(__dirname, `../uploads/certificates/${certificateId}.pdf`);

    const dir = path.dirname(certificatePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    const certificateContent = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                  CERTIFICATE OF ACHIEVEMENT                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

     This is to certify that

          ${activity.student.name}

     has successfully completed

          ${activity.title}

     Category: ${activity.category}
     Level: ${activity.achievementLevel}
     Organizing Body: ${activity.organizingBody || 'N/A'}
     Event Date: ${activity.eventDate ? new Date(activity.eventDate).toLocaleDateString() : 'N/A'}

     Issued on: ${new Date().toLocaleDateString()}

     This certificate is officially recognized.
     Certificate ID: ${certificateId}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Generated by: AchievR - Credential Verification System
    `;

    fs.writeFileSync(certificatePath, certificateContent);
    console.log('âœ… Certificate file created');
    console.log('='.repeat(70) + '\n');

    res.json({
      success: true,
      certificateId,
      certificatePath,
      studentName: activity.student.name,
      studentEmail: activity.student.email,
      studentId: activity.student._id,
      achievement: activity.title,
      organizingBody: activity.organizingBody,
      achievementLevel: activity.achievementLevel,
      eventDate: activity.eventDate?.toLocaleDateString()
    });

  } catch (error) {
    console.error('âŒ Error:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// ========== SUBMIT & SEND EMAIL ==========
router.post('/submit/:activityId', authMiddleware, async (req, res) => {
  try {
    console.log('\n' + '='.repeat(70));
    console.log('ðŸ“§ CERTIFICATE SUBMIT & EMAIL');
    console.log('='.repeat(70));

    const {
      certificateId,
      certificatePath,
      studentName,
      studentEmail,
      studentId,
      achievement,
      organizingBody,
      achievementLevel,
      eventDate
    } = req.body;

    if (!certificateId || !certificatePath || !studentEmail || !studentName) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (!fs.existsSync(certificatePath)) {
      return res.status(404).json({ error: `File not found` });
    }

    const verificationCode = crypto.randomBytes(16).toString('hex');

    // âœ… CHECK IF CERTIFICATE ALREADY EXISTS - IF YES, UPDATE; IF NO, CREATE
    let certificate = await Certificate.findOne({ certificateId });
    
    if (certificate) {
      console.log('âš ï¸ Certificate exists, updating...');
      certificate.verificationCode = verificationCode;
      certificate.emailStatus = 'pending';
    } else {
      certificate = new Certificate({
        certificateId,
        activity: req.params.activityId,
        student: studentId,
        issuedBy: req.user.userId,
        title: achievement,
        organizingBody,
        achievementLevel,
        eventDate,
        pdfPath: certificatePath,
        verificationCode,
        status: 'active'
      });
    }

    await certificate.save();
    console.log('âœ… Certificate saved');

    // SEND EMAIL
    console.log('ðŸ“§ Sending email...');
    try {
      const emailResult = await emailService.sendCertificateEmail(
        studentEmail,
        studentName,
        {
          certificateId,
          certificatePath,
          achievement,
          organizingBody,
          eventDate,
          achievementLevel,
          verificationCode
        }
      );

      if (emailResult.success) {
        await certificate.recordEmailSent(studentEmail, emailResult.messageId, 'sent');
        console.log('âœ… Email sent successfully');
      } else {
        await certificate.recordEmailSent(studentEmail, 'N/A', 'failed', emailResult.error);
      }
    } catch (emailError) {
      console.error('âš ï¸ Email error:', emailError.message);
      await certificate.recordEmailSent(studentEmail, 'N/A', 'failed', emailError.message);
    }

    // UPDATE ACTIVITY
    await Activity.findByIdAndUpdate(req.params.activityId, {
      certificate: certificate._id,
      certificateId,
      status: 'certified',
      certificateGeneratedAt: new Date()
    });

    console.log('='.repeat(70));
    console.log('ðŸŽ‰ SUCCESS!\n');

    res.json({
      success: true,
      message: 'âœ… Certificate created and emailed!',
      certificateId,
      studentEmail,
      emailStats: certificate.getEmailStats()
    });

  } catch (error) {
    console.error('âŒ ERROR:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// ========== BULK SEND - MULTIPLE STUDENTS ==========
router.post('/bulk-send', authMiddleware, async (req, res) => {
  try {
    console.log('\n' + '='.repeat(70));
    console.log('ðŸ“§ BULK SENDING CERTIFICATES');
    console.log('='.repeat(70));

    const user = await User.findById(req.user.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: 'Only admin can bulk send' });
    }

    const { studentIds } = req.body; // Array of student IDs

    if (!studentIds || studentIds.length === 0) {
      return res.status(400).json({ error: 'No students selected' });
    }

    console.log(`ðŸ“§ Sending to ${studentIds.length} students...`);

    let successCount = 0;
    let failCount = 0;
    const results = [];

    for (const studentId of studentIds) {
      try {
        const certificates = await Certificate.find({ 
          student: studentId, 
          emailStatus: { $in: ['pending', 'failed'] }
        });

        if (certificates.length === 0) {
          console.log(`â­ï¸ Student ${studentId}: No pending certificates`);
          continue;
        }

        const student = await User.findById(studentId);
        if (!student || !student.email) {
          console.log(`âŒ Student ${studentId}: Email not found`);
          failCount++;
          continue;
        }

        for (const cert of certificates) {
          try {
            const emailResult = await emailService.sendCertificateEmail(
              student.email,
              student.name,
              {
                certificateId: cert.certificateId,
                certificatePath: cert.pdfPath,
                achievement: cert.title,
                organizingBody: cert.organizingBody,
                eventDate: cert.eventDate,
                achievementLevel: cert.achievementLevel,
                verificationCode: cert.verificationCode
              }
            );

            if (emailResult.success) {
              await cert.recordEmailSent(student.email, emailResult.messageId, 'sent');
              successCount++;
              results.push({ studentName: student.name, certId: cert.certificateId, status: 'sent' });
              console.log(`âœ… Sent to ${student.name}`);
            }
          } catch (err) {
            failCount++;
            console.error(`âŒ Failed for ${student.name}:`, err.message);
          }
        }

      } catch (err) {
        failCount++;
        console.error(`âŒ Error processing student ${studentId}:`, err.message);
      }
    }

    console.log(`\nðŸ“Š Results: ${successCount} sent, ${failCount} failed`);
    console.log('='.repeat(70) + '\n');

    res.json({
      success: true,
      message: `Sent ${successCount} certificates`,
      total: studentIds.length,
      successCount,
      failCount,
      results
    });

  } catch (error) {
    console.error('âŒ ERROR:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// ========== RESEND ALL TO STUDENT ==========
router.post('/resend-to-student/:studentId', authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    const student = await User.findById(req.params.studentId);
    if (!student) {
      return res.status(404).json({ error: 'Student not found' });
    }

    const certificates = await Certificate.find({ student: req.params.studentId, status: 'active' });

    if (certificates.length === 0) {
      return res.status(404).json({ error: 'No certificates found' });
    }

    console.log(`ðŸ“§ Resending ${certificates.length} certificates to ${student.name}...`);

    let successCount = 0;

    for (const cert of certificates) {
      try {
        const emailResult = await emailService.sendCertificateEmail(
          student.email,
          student.name,
          {
            certificateId: cert.certificateId,
            certificatePath: cert.pdfPath,
            achievement: cert.title,
            organizingBody: cert.organizingBody,
            eventDate: cert.eventDate,
            achievementLevel: cert.achievementLevel,
            verificationCode: cert.verificationCode
          }
        );

        if (emailResult.success) {
          await cert.recordEmailSent(student.email, emailResult.messageId, 'sent');
          successCount++;
        }
      } catch (err) {
        console.error(`Error sending cert ${cert.certificateId}:`, err.message);
      }
    }

    res.json({
      success: true,
      message: `Resent ${successCount}/${certificates.length} certificates`,
      studentEmail: student.email,
      total: certificates.length
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ========== DOWNLOAD ==========
router.get('/download/:certificateId', async (req, res) => {
  try {
    const certificate = await Certificate.findById(req.params.certificateId);
    if (!certificate || !fs.existsSync(certificate.pdfPath)) {
      return res.status(404).json({ error: 'Certificate not found' });
    }

    await Certificate.updateOne({ _id: req.params.certificateId }, { $inc: { downloadCount: 1 } });
    res.download(path.resolve(certificate.pdfPath), `${certificate.certificateId}.pdf`);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ========== VERIFY ==========
router.get('/verify/:certificateId', async (req, res) => {
  try {
    const certificate = await Certificate.findById(req.params.certificateId)
      .populate('student', 'name email rollNumber')
      .populate('activity', 'title category');

    if (!certificate || !certificate.isValid) {
      return res.status(404).json({ verified: false, message: 'Certificate not found or revoked' });
    }

    await certificate.recordVerification(req.query.email || 'public', req.ip);

    res.json({
      verified: true,
      data: {
        certificateId: certificate.certificateId,
        studentName: certificate.student.name,
        achievement: certificate.activity.title,
        issuedDate: certificate.issuedAt,
        status: 'Active'
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
